for i, bot in pairs(getBots()) do
    if getBot().name:upper() == bot.name:upper() then
        param = i
    end
end

status = setting.webhook.botstatus
webhook = setting.webhook.storageinfo.link
message = setting.webhook.storageinfo.id
tilebreak = {}
infoid = {}
local identity = {}
identity.goodtime = os.time()
index = 1
local tileBlock = 0
local tileSeed = 0
local tilePack = 0
identity.gaiax = 0
identity.gaiay = 0
identity.utx = 0
identity.uty = 0
strings = ""
seedX = setting.storage.seed.drop.x - 1
seedY = setting.storage.seed.drop.y - 1
packX = setting.storage.pack.drop.x - 1
packY = setting.storage.pack.drop.y - 1
barisX = baris.x - 1
barisY = baris.y - 1

identity.splitt = function(str, ptr)
    if not ptr then 
        ptr = "%s"
    end
    local tbl = {}
    for string in string.gmatch(str, ptr) do
        table.insert(tbl, string) 
    end
    return tbl
end

identity.punchitem = function(x,y)
    for _,tilepunch in pairs(tilebreak) do
        if getTile(x +tilepunch,y -2).fg ~= 0 or getTile(x +tilepunch,y -2).bg ~= 0 then
            return true
        end
    end
    return false
end

for x = math.floor(setting.mode.pnbtile/2),1,-1 do
    x = x * -1
    table.insert(tilebreak,x)
end

for x = 0, math.ceil(setting.mode.pnbtile/2) - 1 do
    table.insert(tilebreak,x)
end

identity.placeitem = function(x,y)
    for _,tileplace in pairs(tilebreak) do
        if getTile(x +tileplace,y -2).fg == 0 and getTile(x+tileplace,y-2).bg == 0 then
            return true
        end
    end
    return false
end

identity.recycles = function()
    for i, trash in ipairs(setting.mode.trashList) do
        if findItem(trash) > setting.mode.amount then
			sendPacket("action|trash\n|itemID|" .. trash,2)
			sleep(2000)
			sendPacket("action|dialog_return\ndialog_name|trash_item\nitemID|" .. trash .. "|\ncount|" .. findItem(trash),2)
			sleep(2000)
        end
    end
end

identity.round = function(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

identity.itemFloat = function(id)
	count = 0
	for _, obj in pairs(getObjects()) do
		if obj.id == id then
			count = count + obj.count
		end
	end
	return count
end

identity.writeFile = function(threads)
    local file = io.open("status.txt","a")
    file:write(threads.."\n")
    file:close()
end

identity.randomguest = function()
    local random_letter = ""
    local function stringRandom()
        local randomm = math.random(1,3)
        if randomm == 1 then
            return string.char(math.random(97,122))
        elseif randomm == 2 then
            return string.char(math.random(65,90))
        else
            return string.char(math.random(48,57))
        end
    end
    for i = 1, account.letter do
        random_letter = random_letter..stringRandom()
    end
    return random_letter
end

identity.randomworld = function()
    local random_letter = ""
    local function stringRandom()
        local randomm = math.random(1,3)
        if randomm == 1 then
            return string.char(math.random(97,122))
        elseif randomm == 2 then
            return string.char(math.random(65,90))
        else
            return string.char(math.random(48,57))
        end
    end
    for i = 1, 15 do
        random_letter = random_letter..stringRandom()
    end
    return random_letter
end

identity.position = function()
    pkt = {}
    pkt.type = 7
    pkt.int_x = math.floor(getBot().x / 32)
    pkt.int_y = math.floor(getBot().y / 32)
    sendPacketRaw(pkt)
end

identity.skiptut = function()
    setJob("Skipping tutorial")
    random_letter = ""
    collectSet(true,2)
    while getTile(math.floor(getBot().x / 32), math.floor(getBot().y / 32)).fg ~= 12 do
        findPath(86,30)
        sleep(1000)
    end
    sendPacket("ftue_start_popup_close",2)
    sleep(500)
    identity.position()
    sleep(1500)
    ::BACK::
    findPath(47,23)
    sleep(2500)
    if math.floor(getBot().x / 32) ~= 47 and math.floor(getBot().y / 32) ~= 23 then
        goto BACK
    end
    sleep(2000)
    while getTile(math.floor(getBot().x / 32)+1,math.floor(getBot().y / 32)).fg ~= 0 do
        punch(1,0)
        sleep(setting.delay.punch)
    end
    sleep(2000)
    ::PLACE::
    place(2,1,0)
    sleep(500)
    if getTile(math.floor(getBot().x / 32)+1,math.floor(getBot().y / 32)).fg ~= 2 then
        goto PLACE
    end
    sleep(1000)
    while getTile(math.floor(getBot().x / 32)+1,math.floor(getBot().y / 32)).fg == 2 do
        punch(1,0)
        sleep(setting.delay.punch)
    end
    sleep(2000)
    while getTile(math.floor(getBot().x / 32)+1,math.floor(getBot().y / 32)).fg ~= 3 do
        place(3,1,0)
        sleep(500)
    end
    sleep(2000)
	while findItem(10672) > 0 do
        if getTile(math.floor(getBot().x / 32)+1, math.floor(getBot().y / 32)).fg == 3 then
            place(10672,1,0)
            sleep(600)
        end
        if getTile(math.floor(getBot().x / 32)+1, math.floor(getBot().y / 32)).fg == 3 then
            punch(1,0)
            sleep(setting.delay.punch)
        end
	end
    sleep(2000)
    wear(48)
    sleep(2000)
    random_letter = identity.randomworld()
    while getTile(math.floor(getBot().x / 32), math.floor(getBot().y / 32)).fg ~= 6 do
        sendPacket("action|join_request\nname|" ..random_letter.."\ninvitedWorld|0", 3)
        sleep(5000)
    end
    while findItem(9640) > 0 do
        if getTile(math.floor(getBot().x / 32), math.floor(getBot().y / 32)-1).fg ~= 9640 then
            place(9640,0,-1)
            sleep(2000)
        end
    end
    collectSet(false)
end

identity.mainacc = function()
    for i, bot in pairs(account.botList) do
        local concept = {}
        for id in bot:gmatch("([^"..account.symbol.."]+)") do 
            table.insert(concept, id) 
        end
        thread = concept[1]
        threads = concept[2]
        num = math.ceil(i / account.proxy.botpersocks)
        if account.proxy.access then
            if account.typeaccount == "guest" then
                if account.macposition == "left" then
                    addBot(identity.randomguest(),true,account.socksList[num])
                    sleep(1000)
                    setMac(thread)
                    setRid(threads)
                    connect()
                elseif account.macposition == "right" then
                    addBot(identity.randomguest(),true,account.socksList[num])
                    sleep(1000)
                    setMac(threads)
                    setRid(thread)
                    connect()
                end
            elseif account.typeaccount == "normal" then
                addBot(thread,threads,account.socksList[num])
            end
        else
            if account.typeaccount == "guest" then
                if account.macposition == "left" then
                    addBot(identity.randomguest())
                    sleep(1000)
                    setMac(thread)
                    setRid(threads)
                    connect()
                elseif account.macposition == "right" then
                    addBot(identity.randomguest())
                    sleep(1000)
                    setMac(threads)
                    setRid(thread)
                    connect()
                end
            elseif account.typeaccount == "normal" then
                addBot(thread,threads)
            end
        end
        sleep(setting.delay.loginbot)
        identity.botinfo("Logging on : [ ||"..getBot().name.."|| ]")
        if account.typeaccount == "normal" then
            while getBot().status ~= "online" do
                connect()
                sleep(setting.delay.reconnect)
                if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "aap detected" then
                    identity.botinfo("Bot growid : [ ||"..getBot().name.."|| ] status is "..getBot().status..", Changing bots if there are still bots remaining @everyone")
                    print("[ "..getBot().name.." ] status is "..getBot().status..", Changing bots if there are still bots remaining")
                    identity.writeFile("[ "..getBot().name.." ] status is "..getBot().status.."")
                    removeBot(getBot().name)
                    sleep(2000)
                    break
                end
            end
        elseif account.typeaccount == "guest" then
            while getBot().status ~= "online" do
                connect()
                sleep(setting.delay.reconnect)
                if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "got captcha" then
                    identity.botinfo("Bot guest : [ "..getMac()..""..account.symbol..""..getRid().." ] status is "..getBot().status..", Changing bots if there are still bots remaining @everyone")
                    print("[ "..getMac()..""..account.symbol..""..getRid().." ] status is "..getBot().status..", Changing bots if there are still bots remaining")
                    identity.writeFile("[ "..getMac()..""..account.symbol..""..getRid().." ] status is "..getBot().status.."")
                    removeBot(getBot().name)
                    sleep(2000)
                    break
                end
            end
        end
        if account.typeaccount == "normal" and getBot().status == "online" then
            if account.proxy.access then
                identity.botinfo("Success add bot to : [ ||"..getBot().name.."|| ], proxy : "..getBot().proxy.."")
            else
                identity.botinfo("Success add bot to : [ ||"..getBot().name.."|| ]")
            end
        elseif account.typeaccount == "guest" and getBot().status == "online"  then
            if account.proxy.access then
                identity.botinfo("Success add bot to : [ "..getMac()..""..account.symbol..""..getRid().." ], proxy : "..getBot().proxy.."")
            else
                identity.botinfo("Success add bot to : [ "..getMac()..""..account.symbol..""..getRid().." ]")
            end
        end
    end
    identity.botinfo("Please change auto add bot to false, then re-execute script @everyone")
    print("Please change auto add bot to false then re-execute script")
    error()
end

identity.backupacc = function()
    backup = bot[param].backup
    thread = identity.splitt(backup[index],"([^"..account.symbol.."]+)")[1]
    threads = identity.splitt(backup[index],"([^"..account.symbol.."]+)")[2]
    num = identity.splitt(backup[index],"([^"..account.symbol.."]+)")[3]
    if account.proxy.access then
        if account.typeaccount == "guest" then
            if account.macposition == "left" then
                addBot(identity.randomguest(),true,num)
                sleep(1000)
                setMac(thread)
                setRid(threads)
                connect()
            elseif account.macposition == "right" then
                addBot(identity.randomguest(),true,num)
                sleep(1000)
                setMac(threads)
                setRid(thread)
                connect()
            end
        elseif account.typeaccount == "normal" then
            addBot(thread,threads,num)
        end
    else
        if account.typeaccount == "guest" then
            if account.macposition == "left" then
                addBot(identity.randomguest())
                sleep(1000)
                setMac(thread)
                setRid(threads)
                connect()
            elseif account.macposition == "right" then
                addBot(identity.randomguest())
                sleep(1000)
                setMac(threads)
                setRid(thread)
                connect()
            end
        elseif account.typeaccount == "normal" then
            addBot(thread,threads)
        end
    end
    sleep(setting.delay.loginbot)
    identity.botinfo("Changing bot to : [ ||"..getBot().name.."|| ]")
    if account.typeaccount == "normal" then
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "aap detected" then
                identity.botinfo("Bot backup : [ ||"..getBot().name.."|| ] status is "..getBot().status..", Terminated script @everyone")
                print("[ "..getBot().name.." ] status is "..getBot().status..", Terminated script")
                identity.writeFile("[ "..getBot().name.." ] status is "..getBot().status.."")
                removeBot(getBot().name)
            end
        end
    elseif account.typeaccount == "guest" then
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "got captcha" then
                identity.botinfo("Bot backup : [ ||"..getBot().name.."|| ] status is "..getBot().status..", Terminated script @everyone")
                print("[ "..getBot().name.." ] status is "..getBot().status..", Terminated script")
                identity.writeFile("[ "..getMac()..""..account.symbol..""..getRid().." ] status is "..getBot().status.."")
                removeBot(getBot().name)
            end
        end
    end
    if account.typeaccount == "normal" and getBot().status == "online" then
        if account.proxy.access then
            identity.botinfo("Success add bot to : [ ||"..getBot().name.."|| ], proxy : "..getBot().proxy.."")
        else
            identity.botinfo("Success add bot to : [ ||"..getBot().name.."|| ]")
        end
    elseif account.typeaccount == "guest" and getBot().status == "online"  then
        if account.proxy.access then
            identity.botinfo("Success add bot to : [ "..getMac()..""..account.symbol..""..getRid().." ], proxy : "..getBot().proxy.."")
        else
            identity.botinfo("Success add bot to : [ "..getMac()..""..account.symbol..""..getRid().." ]")
        end
    end
end

identity.botstatus = function()
    strings = ""
    for _, bot in pairs(getBots()) do
        strings = strings.."\n".."||"..bot.name.."|| :  [ "..string.upper(bot.status).." ]" 
    end
    return strings
end

identity.blockstorage = function()
    strings = ""
	for i = 1, #setting.storage.block.world do
		strings = strings.."\n||"..string.upper(setting.storage.block.world[i]).."|| "..(infoid[setting.storage.block.world[i]] or "?")..""
    end
    return strings
end

identity.seedstorage = function()
    strings = ""
	for i = 1, #setting.storage.seed.world do
		strings = strings.."\n||"..string.upper(setting.storage.seed.world[i]).."|| "..(infoid[setting.storage.seed.world[i]] or "?")..""
    end
    return strings
end

identity.packstorage = function()
    strings = ""
	for i = 1, #setting.storage.pack.world do
		strings = strings.."\n||"..string.upper(setting.storage.pack.world[i]).."|| "..(infoid[setting.storage.pack.world[i]] or "?")..""
    end
    return strings
end

identity.botgems = function()
    local count = 0
    for _,bot in pairs(getBots()) do
        count = count + bot.gems
    end
    return count
end

identity.botinfo = function(content)
	if setting.webhook.access then
		text = [[
			$webHookUrl = "]]..status..[["
			$payload = @{
				content = "]]..content..[["
			}
			[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
			Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Post -ContentType "application/json"
		]]
		local file = io.popen("powershell -command -", "w")
		file:write(text)
		file:close()
	end
end

identity.goodtimes = function(estimates)
    local seconds = tonumber(estimates)
    if seconds <= 0 then
        return "00:00:00";
    else
        hours = string.format("%02.f", math.floor(estimates/3600));
        minutes = string.format("%02.f", math.floor(estimates/60 - (hours*60)));
        seconds = string.format("%02.f", math.floor(estimates - hours*3600 - minutes *60));
        return ""..hours.." : "..minutes.." : "..seconds
    end
end

identity.webhookinfo = function()
	if setting.webhook.access then
        local text = [[
            $webHookUrl = "]]..webhook..[[/messages/]]..message..[["
            $payload = @{
                username = "BizzantiuM's"
                embeds = @(
                    @{
                        title = "AUTO PNB v1.0 [ ]]..string.upper(setting.type)..[[ ]"
                        color = "]]..math.random(111111,999999)..[["
                        fields = @(
                            @{
                                name = "BOT INFO"
                                value = "]].."**RUNNING : [ "..identity.goodtimes(os.difftime(os.time(),identity.goodtime)).." ]\nTOTAL GEMS : "..identity.botgems().."**\n"..identity.botstatus()..""..[["
                                inline = "false"
                            }
                            @{
                                name = "STORAGE STATIC"
                                value = "]]..""..[["
                                inline = "false"
                            }
                            @{
                                name = "BLOCK"
                                value = "]]..identity.blockstorage()..[["
                                inline = "true"
                            }
                            @{
                                name = "SEED"
                                value = "]]..identity.seedstorage()..[["
                                inline = "true"
                            }
                            @{
                                name = "PACK"
                                value = "]]..identity.packstorage()..[["
                                inline = "true"
                            }
                        )
                        footer = @{
                            text = "Developed by BizzantiuM's`nLast updated : ]]..(os.date"%d/%m/%y":upper().." at ")..os.date("%I")..":"..os.date("%M").." "..os.date("%p"):upper()..[["
                        }
                    }
                )
            }
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Patch -ContentType 'application/json'
        ]]
        local pipe = io.popen("powershell -command -", "w")
        pipe:write(text)
        pipe:close()
    end
end

identity.reconnect = function(world,id,x,y)
    if getBot().level >= switch.maxlevel then
        if switch.access then
            while findItem(setting.item.seed) > 0 do
                identity.storingseeds()
            end
            while findItem(setting.item.block) > 0 do
                identity.storingblocks()
            end
            identity.botinfo("[ ||"..getBot().name.."|| ] has reached level limit, changing bot")
            removeBot(getBot().name)
            sleep(2000)
            identity.backupacc()
        end
    end
    if getBot().world == "EXIT" then 
        identity.botinfo("[ ||"..getBot().name.."|| ] stuck EXIT ??, trying to joining world again @everyone")
        print("[ "..getBot().name.." ] stuck EXIT ??, trying to joining world again")
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
            sleep(setting.delay.warp)
        end
        if id ~= "" then
            while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
                sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
                sleep(setting.delay.warp)
            end
        end
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(100)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] success to joining world @everyone")
        print("[ "..getBot().name.." ] success to joining world")
    end
    if getBot().status ~= "online" then
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "ercon" then
                identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status..", Changing bot if backup mode enable @everyone")
                print("[ "..getBot().name.." ] status is "..getBot().status..", Changing bot if backup mode enable")
                removeBot(getBot().name)
                sleep(2000)
                error()
            end
        end
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        if id ~= "" then
            while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
                sendPacket("action|join_request\nname|"..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
                sleep(setting.delay.warp)
            end
        end
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(150)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
    end
    while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
        identity.botinfo("[ ||"..getBot().name.."|| ] back to white door, what happened?! trying back to position")
        print("[ "..getBot().name.." ] back to white door, what happened?! trying back to position")
        sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
        sleep(setting.delay.warp)
        if x and y then
            while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                findPath(x,y)
                sleep(100)
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] already back to position")
        print("[ "..getBot().name.." ] already back to position")
    end
end

identity.warp = function(world,door)
    name = world
    if door then
        name = name .. "|" ..door
    end
    if getBot().world ~= string.upper(world) then
        addHook("onvariant","nuked",function (varlist)
            if varlist[0] == "OnConsoleMessage" then
                if string.find(varlist[1],"inaccessible.") then
                    nuked = true
                end
            end
        end)
        while getBot().world ~= string.upper(world) and not nuked do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        removeHooks()
        sleep(1000)
    end
    if door and getBot().world == string.upper(world) then
        local stuck = 0
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 and not wrong do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

identity.takepickaxe = function()
    world = identity.splitt(account.takepickaxe.world[index],"[^:]+")[1]
    door = identity.splitt(account.takepickaxe.world[index],"[^:]+")[2]
    setJob("Take pickaxe")
    identity.warp(world,door)
    if not nuked then
        if not wrong then
            while findItem(98) == 0 do
                for _, obj in pairs(getObjects()) do
                    if obj.id == 98 then
                        findPath(math.floor(obj.x / 32),math.floor(obj.y / 32))
                        sleep(1000)
                        collect(2)
                        sleep(1000)
                    end
                    if findItem(98) > 0  then
                        break
                    end
                end
            end
            wear(98)
            sleep(500)
            move(-1,0)
            sleep(1000)
            drop(98,findItem(98) - 1)
            sleep(1000)
        else
            print("Id door world take support items is wrong, check ur id door !!")
            infoBot("Id door world take support items is wrong, check ur id door !! @everyone")
            error()
        end
    else
        print("World take support items is nuked, check ur world !!")
        infoBot("World take support items is nuked, check ur world !! @everyone")
        error()
    end
end

identity.buying = function(threads)
    if findItem(112) >= setting.pack.mingems then
        while findItem(112) >= setting.pack.mingems do
            while getBot().slots < 36 do
                sendPacket("action|buy\nitem|upgrade_backpack",2)
                sleep(1000)
            end
            while findItem(112) > setting.pack.price do
                sendPacket("action|buy\nitem|"..setting.pack.debug,2)
                sleep(1000)
                if findItem(setting.pack.packList[1]) >= 200 then
                    break
                end
            end
        end
    end
end

identity.storingpacks = function()
    for i = index , #setting.storage.pack.world do
        setJob("Dropping packs")
        world = setting.storage.pack.world[i]
        door = setting.storage.pack.door
        identity.warp(world,door)
        identity.webhookinfo()
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.pack.packList[1]) >= setting.storage.pack.limit then
                    infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."] LIMIT !!!"
                    identity.botinfo("Packs storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Packs storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.pack.world then
                        infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."] LIMIT !!!"
                        identity.botinfo("All packs storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                        print("All packs storage has reached limit, Removing bot : [ "..getBot().name.." ]")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tilePack = 0
                else
                    for y,pack in pairs(setting.pack.packList) do
                        for i,tile in pairs(getTiles()) do
                            if setting.pack.separated then
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(packX + (tilePack),packY - (y-1))
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,door,packX + (tilePack),packY - (y-1))
                                    if packX + (tilePack) >= 98 then
                                        packY = packY - 1
                                        tilePack = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,door,packX + (tilePack),packY - (y-1))
                                        count = count + 1
                                        if count >= 2 then
                                            tilePack = tilePack + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            else
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(packX + (tilePack),packY)
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,door,packX + (tilePack),packY)
                                    if packX + (tilePack) >= 98 then
                                        packY = packY - 1
                                        tilePack = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,door,packX + (tilePack),packY)
                                        count = count + 1
                                        if count >= 2 then
                                            tilePack = tilePack + 1
                                            goto BACK
                                        end
                                    end
                                end
                                if findItem(pack) == 0 then
                                    break
                                end
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door packs storage is wrong, check ur id door!")
                identity.botinfo("[ ||"..getBot().world.."|| ] Id door packs storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.pack.world then
                    print("All packs storage has reached limit")
                    identity.botinfo("All packs storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tilePack = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] packs Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] packs Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.pack.world then
                print("All packs storage has reached limit!")
                identity.botinfo("All packs storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tilePack = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.pack.packList[1]).."]"
end

identity.storingseeds = function()
    for i = index , #setting.storage.seed.world do
        world = setting.storage.seed.world[i]
        door = setting.storage.seed.door
        setJob("Dropping seeds")
        identity.warp(world,door)
        identity.webhookinfo()
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.item.seed) >= setting.storage.seed.limit then
                    infoid[world] = "["..identity.itemFloat(setting.item.seed).."] LIMIT !!!"
                    identity.botinfo("Seeds storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Seeds storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.seed.world then
                        infoid[world] = "["..identity.itemFloat(setting.item.seed).."] LIMIT !!!"
                        identity.botinfo("All seeds storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                        print("All seeds storage has reached limit, Removing bot : [ "..getBot().name.." ] @everyone")
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tileSeed = 0
                else
                    for i,tile in pairs(getTiles()) do
                        if tile.fg == 0 or tile.bg == 0 then
                            ::BACK::
                            findPath(seedX + (tileSeed),seedY)
                            sleep(1000)
                            local count = 0
                            identity.reconnect(world,door,seedX + (tileSeed),seedY)
                            if seedX + (tileSeed) >= 98 then
                                seedY = seedY - 1
                                tileSeed = 0
                            end
                            while findItem(setting.item.seed) > 0 do
                                drop(setting.item.seed)
                                sleep(setting.delay.drop)
                                identity.reconnect(world,door,seedX + (tileSeed),seedY)
                                count = count + 1
                                if count >= 2 then
                                    tileSeed = tileSeed + 1
                                    goto BACK
                                end
                            end
                        end
                        if findItem(setting.item.seed) == 0 then
                            break
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door seeds storage is wrong, check ur id door!")
                identity.botinfo("[ "..getBot().world.." ] Id door seeds storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.seed.world then
                    print("All seeds storage has reached limit")
                    identity.botinfo("All seeds storage has reached limit @everyone")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tileSeed = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] seeds Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] seeds Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.seed.world then
                print("All seeds storage has reached limit!")
                identity.botinfo("All seeds storage has reached limit! @everyone")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tileSeed = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.item.seed).."]"
end

identity.storingblocks = function()
    for i = index , #setting.storage.block.world do
        world = setting.storage.block.world[i]
        door = setting.storage.block.door
        setJob("Dropping blocks")
        identity.warp(world,door)
        identity.webhookinfo()
        if not nuked then
            if not wrong then
                for _, object in pairs(getObjects()) do
                    if object.id == setting.item.block then
                        findPath(identity.round((object.x)/32), math.floor((object.y)/32))
                        sleep(1000)
                        drop(setting.item.block)
                        sleep(1000)
                    end
                    if findItem(setting.item.block) == 0  then
                        break
                    end
                end
                sleep(100)
                break
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door blocks storage is wrong, check ur id door!")
                identity.botinfo("[ "..getBot().world.." ] Id door blocks storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.block.world then
                    print("All blocks storage has reached limit")
                    identity.botinfo("All blocks storage has reached limit @everyone")
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] blocks Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] blocks Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.block.world then
                print("All blocks storage has reached limit!")
                identity.botinfo("All blocks storage has reached limit! @everyone")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
        end
    end
end

identity.take = function()
    for i = index , #setting.storage.block.world do
        setJob("Take blocks")
		world = setting.storage.block.world[i]
        door = setting.storage.block.door
        identity.warp(world,door)
        identity.webhookinfo()
		if not nuked then
			if not wrong then
				if identity.itemFloat(setting.item.block) == 0 then
					infoid[world] = ""..identity.itemFloat(setting.item.block).." EMPTY !!"
					identity.botinfo("Blocks storage : [ ||"..getBot().world.."|| ] has empty, skipped world @everyone")
					print("Blocks storage : [ "..getBot().world.." ] has empty, skipped world")
					index = index + 1
					if index > #setting.storage.block.world then
						infoid[world] = ""..identity.itemFloat(setting.item.block).." EMPTY !!"
						identity.botinfo("All blocks storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
						print("All blocks storage has empty, Removing bot : [ "..getBot().name.." ]")
						identity.webhookinfo("All blocks storage has empty, Removing bot!")
						if setting.mode.removeBot then
							removeBot(getBot().name)
							sleep(100)
						end
						error()
					end
				else
					for _, object in pairs(getObjects()) do
						if object.id == setting.item.block then
							findPath(identity.round((object.x)/32), math.floor((object.y)/32))
							sleep(500)
							collect(2)
							sleep(500)
						end
						if findItem(setting.item.block) >= setting.mode.pnbtile then
							break
						end
					end
					sleep(100)
					break
				end
			else
				infoid[world] = "WRONG DOOR ID"
				wrong = false
				sleep(1000)
				identity.botinfo("Blocks storage : [ ||"..getBot().world.."|| ] is wrong door id, skipped world @everyone")
				print("Blocks storage : [ "..getBot().world.." ] is wrong door id, skipped world")
				index = index + 1
				if blockd > #setting.storage.block.world then
					identity.botinfo("All blocks storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
					print("All blocks storage has empty, Removing bot : [ "..getBot().name.." ]")
					if setting.mode.removeBot then
						removeBot(getBot().name)
						sleep(100)
					end
					error()
				end
			end
		else
			infoid[world] = "NUKED"
			nuked = false
			sleep(1000)
			identity.botinfo("Blocks storage : [ ||"..getBot().world.."|| ] is NUKED, skipped world @everyone")
			print("Blocks storage : [ "..getBot().world.." ] is NUKED, skipped world")
			index = index + 1
			if seedd > #setting.storage.block.world then
				identity.botinfo("All blocks storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
				print("All blocks storage has empty, Removing bot : [ "..getBot().name.." ]")
				if setting.removeBot then
					removeBot(getBot().name)
					sleep(100)
				end
				error()
			end
		end
	end
	infoid[world] = ""..identity.itemFloat(setting.item.block)..""
    identity.line()
end

identity.line = function()
    custompnb = bot[param].customworld
    identity.param = 0
    setJob("PNB")
    identity.webhookinfo()
    if not different.access then
        world = identity.splitt(different.worldpnb[index],"[^:]+")[1]
        door = identity.splitt(different.worldpnb[index],"[^:]+")[2]
        identity.warp(world,door)
        if not nuked then
            if not wrong then
                if setting.type == "nogaut" then
                    if setting.mode.pnbtile == 1 then
                        identity.botline = setting.mode.pnbtile + 3
                        for _,tile in pairs(getTiles()) do
                            for strs,bot in pairs(getBots()) do
                                if bot.name == getBot().name then
                                    findPath(barisX - identity.param,barisY)
                                    sleep(1000)
                                    collect(1,112)
                                    identity.reconnect(world,door,barisX,barisY)
                                    break
                                else
                                    identity.param = identity.param + identity.botline
                                end
                            end
                            break
                        end
                    else
                        identity.botline = setting.mode.pnbtile + 1
                        for _,tile in pairs(getTiles()) do
                            for strs,bot in pairs(getBots()) do
                                if bot.name == getBot().name then
                                    findPath(barisX - identity.param,barisY)
                                    sleep(1000)
                                    collect(1,112)
                                    identity.reconnect(world,door,barisX,barisY)
                                    break
                                else
                                    identity.param = identity.param + identity.botline
                                end
                            end
                            break
                        end
                    end
                elseif setting.type == "gaut" then
                    identity.botline = setting.mode.pnbtile
                    for _,tile in pairs(getTiles()) do
                        for strs,bot in pairs(getBots()) do
                            if bot.name == getBot().name then
                                findPath(barisX - identity.param,barisY)
                                sleep(1000)
                                collect(1,112)
                                identity.reconnect(world,door,barisX,barisY)
                                break
                            else
                                identity.param = identity.param + identity.botline
                            end
                        end
                        break
                    end
                end
            else
                identity.botinfo("World pnb : [ ||"..world.."|| ] is Wrong door, terminated script @everyone")
                print("World pnb : [ "..world.." ] is Wrong door, terminated script")
                error()
            end
        else
			identity.botinfo("World pnb : [ ||"..world.."|| ] is NUKED @everyone")
			print("World pnb : [ "..world.." ] is NUKED, terminated script")
            error()
        end
    else
        world = identity.splitt(custompnb[index],"[^:]+")[1]
        door = identity.splitt(custompnb[index],"[^:]+")[2]
        identity.warp(world,door)
        if not nuked then
            if not wrong then
                findPath(barisX,barisY)
                sleep(1000)
                collect(1,112)
                identity.reconnect(world,door,barisX,barisY)
            else
                identity.botinfo("World pnb : [ ||"..world.."|| ] is Wrong door, terminated script @everyone")
                print("World pnb : [ "..world.." ] is Wrong door, terminated script")
                error()
            end
        else
			identity.botinfo("World pnb : [ ||"..world.."|| ] is NUKED, terminated script @everyone")
			print("World pnb : [ "..world.." ] is NUKED, terminated script")
            error()
        end
    end
    identity.pnb()
end

identity.pnb = function()
    custompnb = bot[param].customworld
    setJob("PNB")
    botX = math.floor(getBot().x / 32)
    botY = math.floor(getBot().y / 32)
    if not different.access then
        if setting.mode.pnbtile == 1 then
            while findItem(setting.item.block) >= setting.mode.pnbtile do
                botX = math.floor(getBot().x / 32)
                botY = math.floor(getBot().y / 32)
                world = identity.splitt(different.worldpnb[index],"[^:]+")[1]
                door = identity.splitt(different.worldpnb[index],"[^:]+")[2]
                if getTile(botX,botY -2).bg ~= 0 or getTile(botX, botY -2).fg ~= 0 then
                    punch(0,-2)
                    sleep(setting.delay.punch)
                    identity.reconnect(world,door,botX,botY)
                end
                if getTile(botX,botY -2).bg == 0 or getTile(botX, botY -2).fg == 0 then
                    place(setting.item.block,0,-2)
                    sleep(setting.delay.place)
                    identity.reconnect(world,door,botX,botY)
                end
                if setting.type == "nogaut" then
                    collect(2)
                    sleep(30)
                elseif setting.type == "gaut" then
                    collect(2,112)
                    sleep(30)
                end
                if findItem(setting.item.seed) >= 150 then
                    setJob("Storing seed")
                    identity.storingseeds()
                    setJob("PNB")
                    identity.line()
                elseif findItem(112) >= setting.pack.mingems and setting.type == "nogaut" then
                    identity.buying()
                    identity.storingpacks()
                    identity.line()
                end
            end
        else
            while findItem(setting.item.block) >= setting.mode.pnbtile do
                world = identity.splitt(different.worldpnb[index],"[^:]+")[1]
                door = identity.splitt(different.worldpnb[index],"[^:]+")[2]
                while identity.placeitem(botX,botY) do
                    for _,i in pairs(tilebreak) do
                        if getTile(botX + i,botY -2).fg == 0 and getTile(botX + i,botY - 2).bg == 0 then
                            place(setting.item.block,i,-2)
                            sleep(setting.delay.place)
                            identity.reconnect(world,door,botX,botY)
                        end
                    end
                end
                while identity.punchitem(botX,botY) do
                    for _,i in pairs(tilebreak) do
                        if getTile(botX + i,botY -2).fg ~= 0 or getTile(botX + i,botY - 2).bg ~= 0 then
                            punch(i,-2)
                            sleep(setting.delay.punch)
                            identity.reconnect(world,door,botX,botY)
                        end
                    end
                end
                if setting.type == "nogaut" then
                    collect(3)
                    sleep(30)
                elseif setting.type == "gaut" then
                    collect(3,112)
                    sleep(30)
                end
                if findItem(setting.item.seed) >= 150 then
                    identity.storingseeds()
                    identity.line()
                elseif findItem(112) >= setting.pack.mingems and setting.type == "nogaut" then
                    identity.buying()
                    identity.storingpacks()
                    identity.line()
                end
            end
        end
    else
        if setting.mode.pnbtile == 1 then
            while findItem(setting.item.block) >= setting.mode.pnbtile do
                botX = math.floor(getBot().x / 32)
                botY = math.floor(getBot().y / 32)
                world = identity.splitt(custompnb[index],"[^:]+")[1]
                door = identity.splitt(custompnb[index],"[^:]+")[2]
                if getTile(botX,botY -2).bg ~= 0 or getTile(botX, botY -2).fg ~= 0 then
                    punch(0,-2)
                    sleep(setting.delay.punch)
                    identity.reconnect(world,door,botX,botY)
                end
                if getTile(botX,botY -2).bg == 0 or getTile(botX, botY -2).fg == 0 then
                    place(setting.item.block,0,-2)
                    sleep(setting.delay.place)
                    identity.reconnect(world,door,botX,botY)
                end
                if setting.type == "nogaut" then
                    collect(2)
                    sleep(30)
                elseif setting.type == "gaut" then
                    collect(2,112)
                    sleep(30)
                end
                if findItem(setting.item.seed) >= 150 then
                    setJob("Storing seed")
                    identity.storingseeds()
                    setJob("PNB")
                    identity.line()
                elseif findItem(112) >= setting.pack.mingems and setting.type == "nogaut" then
                    identity.buying()
                    identity.storingpacks()
                    identity.line()
                end
            end
        else
            while findItem(setting.item.block) >= setting.mode.pnbtile do
                world = identity.splitt(custompnb[index],"[^:]+")[1]
                door = identity.splitt(custompnb[index],"[^:]+")[2]
                while identity.placeitem(botX,botY) do
                    for _,i in pairs(tilebreak) do
                        if getTile(botX + i,botY -2).fg == 0 and getTile(botX + i,botY - 2).bg == 0 then
                            place(setting.item.block,i,-2)
                            sleep(setting.delay.place)
                            identity.reconnect(world,door,botX,botY)
                        end
                    end
                end
                while identity.punchitem(botX,botY) do
                    for _,i in pairs(tilebreak) do
                        if getTile(botX + i,botY -2).fg ~= 0 or getTile(botX + i,botY - 2).bg ~= 0 then
                            punch(i,-2)
                            sleep(setting.delay.punch)
                            identity.reconnect(world,door,botX,botY)
                        end
                    end
                end
                if setting.type == "nogaut" then
                    collect(3)
                    sleep(30)
                elseif setting.type == "gaut" then
                    collect(3,112)
                    sleep(30)
                end
                if findItem(setting.item.seed) >= 150 then
                    setJob("Storing seed")
                    identity.storingseeds()
                    setJob("PNB")
                    identity.line()
                elseif findItem(112) >= setting.pack.mingems and setting.type == "nogaut" then
                    identity.buying()
                    identity.storingpacks()
                    identity.line()
                end
            end
        end
    end
    if setting.type == "nogaut" then
        if setting.mode.storeseedafterpnb then
            identity.storingseeds()
            identity.take()
        else
            identity.take()
        end
    elseif setting.type == "gaut" then
        for _, object in pairs(getObjects()) do
            if object.id == setting.item.seed then
                findPath(identity.round((object.x)/32), math.floor((object.y)/32))
                sleep(1000)
                collect(3,112)
            end
            if findItem(setting.item.seed) > 0 then
                identity.storingseeds()
                identity.take()
            else
                identity.take()
            end
        end
    end
end

function hook(varlist)
	if varlist[0] == "OnDialogRequest" and varlist[1]:find("add_label_with_icon|big|`wUnstable Tesseract``|left|6948|") then
		if varlist[1]:find("The machine is currently empty!") then 
            sleep(1000)
		else
			amount = varlist[1]:match("The machine contains (%d+)")
			amounts = 1
			if tonumber(amount) >= 200 then 
				amounts = 200 
			end
			if tonumber(amount) < 200 then 
				amounts = tonumber(amount) 
			end
            local utpkt = string.format([[action|dialog_return
            dialog_name|itemsucker_block
            tilex|%d|
            tiley|%d|
            buttonClicked|retrieveitem
            chk_enablesucking|1
            ]], varlist[1]:match("tilex|(%d+)"), varlist[1]:match("tiley|(%d+)"))
            sleep(1000)
            sendPacket(utpkt,2)
            sleep(1000)
            local utpkt = string.format([[action|dialog_return
            dialog_name|itemremovedfromsucker
            tilex|%d|
            tiley|%d|
            itemtoremove|%d]], varlist[1]:match("tilex|(%d+)") , varlist[1]:match("tiley|(%d+)") , amounts)
            sleep(1000)
            sendPacket(utpkt,2)
            sleep(1000)
        end
    end
	if varlist[0] == "OnDialogRequest" and varlist[1]:find("add_label_with_icon|big|`wGaia's Beacon``|left|6946|") then
		if varlist[1]:find("The machine is currently empty!") then 
            sleep(1000)
		else
			ammount = varlist[1]:match("The machine contains (%d+)")
			ammounts = 1
			if tonumber(ammount) >= 200 then 
				ammounts = 200 
			end
			if tonumber(ammount) < 200 then 
				ammounts = tonumber(ammount) 
			end
            local gaiapkt = string.format([[action|dialog_return
            dialog_name|itemsucker_seed
            tilex|%d|
            tiley|%d|
            buttonClicked|retrieveitem
            chk_enablesucking|1
            ]], varlist[1]:match("tilex|(%d+)") , varlist[1]:match("tiley|(%d+)"))
            sleep(1000)
            sendPacket(gaiapkt,2)
            sleep(1000)
            local gaiapkt = string.format([[action|dialog_return
            dialog_name|itemremovedfromsucker
            tilex|%d|
            tiley|%d|
            itemtoremove|%d]], varlist[1]:match("tilex|(%d+)") , varlist[1]:match("tiley|(%d+)") , ammounts)
            sleep(1000)
            sendPacket(gaiapkt,2)
            sleep(1000)
        end
	end
end

addHook("onvariant","retrieve",hook)

identity.setposition = function()
    for _, bot in pairs(setting.mode.retrieve.growid) do
        if bot == getBot().name then
            world = identity.splitt(different.worldpnb[index], "[^:]+")[1]
            door = identity.splitt(different.worldpnb[index], "[^:]+")[2]
            setJob("Retrieve")
            identity.warp(world,door)
            for i , tile in pairs(getTiles()) do
                if tile.fg == 6948 then
                    findPath(tile.x,tile.y-1)
                    sleep(100)
                    identity.utx = math.floor(getBot().x / 32)
                    identity.uty = math.floor(getBot().y / 32)
                    sleep(100)
                end
            end
            for i , tile in pairs(getTiles()) do
                if tile.fg == 6946 then
                    findPath(tile.x,tile.y-1)
                    sleep(100)
                    identity.gaiax = math.floor(getBot().x / 32)
                    identity.gaiay = math.floor(getBot().y / 32)
                    sleep(100)
                end
            end
        end
    end
end

if BizzantiuM.version == "1.0" and BizzantiuM.handler == "akbarsht" then
    if account.access then
        identity.mainacc()
    end
    if getBot().world:find("TUTORIAL") then
        if account.skiptutor then
            identity.skiptut()
        end
    end
    if findItem(98) == 0 and account.takepickaxe.access and getBot().status == "online" then
        identity.takepickaxe()
    end
    if setting.mode.retrieve.access then
        identity.setposition()
        while true do
            findPath(identity.utx,identity.uty)
            sleep(setting.delay.retrieve)
            wrench(0,1)
            sleep(setting.delay.retrieve*2)
            if findItem(setting.item.seed) > 0 then
                while findItem(setting.item.seed) > 0 do
                    drop(setting.item.seed)
                    sleep(setting.delay.drop)
                    if findItem(setting.item.seed) == 0 then
                        break
                    end
                end
            end
            sleep(1500)
            findPath(identity.gaiax,identity.gaiay)
            sleep(setting.delay.retrieve)
            wrench(0,1)
            sleep(setting.delay.retrieve*2)
            if findItem(setting.item.block) > 0 then
                while findItem(setting.item.block) > 0 do
                    drop(setting.item.block)
                    sleep(setting.delay.drop)
                    if findItem(setting.item.block) == 0 then
                        break
                    end
                end
            end
        end
    else
        identity.take()
    end
end
